# 进程

## 1. 进程和程序
- 进程是程序运行的一个实例。
- 程序是包含了一系列信息的文件，这些信息描述了如何在运行时创建一个进程:
  - 1. 二进制格式标识: 通常的二进制文件格式有如下的格式:
    - PE COFF: windows平台的二级制格式
    - COFF: Unix早期的通用对象文件格式。
    - a.out: 汇编程序输出格式。
    - ELF: Unix/Linux现在使用的格式，相对COFF有很多优点。
  - 2. 机器语言指令: 对程序算法进行编码。
  - 3. 程序入库地址(main函数入库点): 标志程序开始执行的起始指令位置。
  - 4. 数据: 程序文件包含的变量初始值和程序使用的字面常量值(如字符串)。
  - 5. 符号表和重定位表: 描述程序中的函数和变量的位置(地址)和名称。可以用于调试和运行时的符号解析(动态链接)。
  - 6. 共享库和动态链接库信息: 程序文件所包含的一些字段，列出了程序运行时需要使用的**共享库**，以及加载共享库的**动态链接器的路径名**。
  - 7. 其他信息。
- 重定义进程: 进程是由内核定义抽象的实体，并为该实体分配用以执行程序的各项系统资源。
- **从内核角度来看**，进程由**用户内存空间**和一系列**内核数据结构**组成。
  - 用户内存空间: 包含了程序代码和代码使用的变量
  - 内核数据结构: 维护进程状态信息，这些信息包括:
    - 进程相关的标识号(IDs): pid,ppid等。
    - 虚拟内存表,
    - 打开文件的描述符表,
    - 信号传递及处理的有关信息,
    - 进程资源使用及限制,
    - 当前工作目录,
    - 大量的其他信息。

## 2. 进程号和父进程号
- 每个进程都有一个进程号，用于标志系统中的唯一的一个进程，进程号是个正数。通常进程号可以作为参数，向对应的进程发送信号。
- 除了init进程号为1外，其他进程与进程号没有对应关系。
- linux内核限制进程号需小于等于32767。新创建进程时，内核会按照顺序分配一个进程号给其使用。每当进程号达到32767时，内核将重置进程号计数器，以便从小整数开始分配。通常都是从300开始，因为小整数通常都分配给系统进程了。
- **注意**: linux2.4及更早版本的进程号最大值是32767，2.6之后的版本有所变化：尽管默认的最大值仍然是32767，但是可以通过`/proc/sys/kernel/pid_max`文件来进行调整(其值=最大进程号+1),32位平台最大值为32767,64位系统最大值可以达到2^22(约400万)。
- 获取进程号/父进程号函数
  - 原型: 
  ```c
  #include <unistd.h>
  pid_t getpid(void);
  pid_t getppid(void);
  ```
- 实际上，可以通过父进程形成整个系统的进程树。最终可以追踪到树根，init进程。但是当一个进程的父进程终止了，则子进程会成为`孤儿`，这个`孤儿`将被`init`进程收养。
- 可以通过`/proc/<PID>/status`查看进程的父进程。

## 3. 进程内存布局
- 内核为进程分配的内存由很多部分组成，通常称之为`段(segment)`:
  - 文本段: 进程运行的程序机器语言指令，文本段具有只读属性。当多个进程运行同一份程序时，将在内存中共享这个段。
  - 初始化数据段: 显式初始化的全局变量和静态变量。
  - 未初始化数据段: 也称为BSS(block started by symbol)段，通常未初始化的数据段，在磁盘上并不用开辟空间存储，只是记住位置和大小，在程序运行时由程序加载器来分配这一空间。
  - 栈: 动态增长和收缩的段，由栈帧组成。系统会为每一个函数调用分配一个栈帧，栈帧中包含函数的局部变量、实参和返回值。函数调用结束后，栈回收。
  - 堆: 可在运行时为变量动态分配内存的一块区域，堆顶称作: program break.
- size指令可以查看二级制文件的各个段大小
- 上面的组成部分在使用了非优化的编译器，如果编译器采用了优化，通常是使用栈来传递参数，实际上优化编译器将会频繁的使用的变量分配于寄存器中，或者索性将变量彻底删除。此外一些ABI需要通过寄存器，而不是栈，来传递函数参数和结果。
- **注意**: 虽然SUSv3未做规定，但是大多数Unix实现，包括linux中C语言编程环境中提供了三个全局符号: etext/edata/end, 可在程序内使用这些符号以获取相应程序文本段、初始化数据段和未初始化数据段结尾处的下一字节的地址。要使用这些符号，必须显式声明如下:
  - extern char etext, edata, end;

## 4. 虚拟内存管理**重点学习**
- linux采用了虚拟内存管理技术，该技术利用了程序的一个典型特征: 访问局部性，以求高效使用CPU和RAM资源。
  - 空间局部性: 程序倾向于访问在最近访问过的内存地址附件的内存(由于指令是顺序执行的，且有时会按照顺序处理数据结构)。
  - 时间局部性: 程序倾向于在不就的将来再次访问最近刚访问过的内存地址(由于循环的存在)。
- 由于访问局部性的特征，使得程序即便仅有部分地址空间存在于RAM中，依然得以执行。之前我们的电脑内存很小，有很多程序并不能全部加载到内存，这就使得小内存能够运行大程序成为可能。
- 虚拟内存的规划之一是将每个程序使用的内存切割成小型的、固定大小的页(page)单元，相应地，将RAM划分成一系列与虚存页(page)尺寸相同的页帧(page frame)。
  - 任意时刻，每个程序仅有部分页需要驻留在物理内存页帧中。这些页构成了所谓**驻留集**(resident set)。
  - 程序未使用的页拷贝保存到**交换区(swap area)**内: 这是磁盘空间中的保留区域，作为计算机RAM的补充: 仅在需要时才会载入物理内存。
  - 若进程欲访问的页面目前并未驻留在物理内存中，将会发生**页面错误(page fault)**, 即缺页异常，内核将挂起进程的运行，同时从磁盘中将该页面载入内存。这一过程将伴随着页表的修改。
- 为了支持这一组织方式，内核需要为每一个进程维护一张**页表(page table)**，页表中的行，描述了**每页(page)**在进程**虚拟地址空间(virtual address page)**中的位置。即: `(页，虚拟内存地址，RAM地址/磁盘上)`表明: 
  - 1. `(页，虚拟内存地址，RAM地址)` 页驻留在内存中。
  - 2. `(页，虚拟内存地址，磁盘上)` 页被换出到了交换区。
- 在进程的虚拟地址空间中，并非所有的地址范围都需要页表条目。通常情况下，由于可能存在大段的虚拟地址空间并未投入使用，故并不需要为其维护相应的页表条目。若进程试图访问这些地址，并且这些地址并未在页表中，那么进程将收到一个`SIGSEGV`信号，即内存地址访问异常。
- 内核能够为进程分配和释放页(同时也会修改页表的条目)，进程的有效虚拟内存地址范围在其生命周期中可以发生变化，下面的场景将触发这一变化:
  - 1. 栈向下增长超出之前曾到达的位置。
  - 2. 当在堆中分配或释放内存时，调用brk()/sbrk()/malloc()等函数来提升`program break`的位置。
  - 3. 当调用`shmat()`连接System V共享内存区时，或者调用`shmdt()`脱离内存共享区时。
  - 4. 当调用`mmap()`创建内存映射时，或者调用`munmap()`解除内存映射时。
- 虚拟内存的实现需要硬件中分页内存管理单元(PMMU)支持，PMMU把要访问的每个虚拟内存地址转换为相应的物理内存地址，当特定的虚拟内存地址对应的页没有驻留在内存中时，将以页面错误通知内核。
- 虚拟内存管理使进程的虚拟地址空间与RAM的物理内存空间**隔离**开来，这样带来了很多的优点:
  - 1. 进程与进程，内核与进程相互隔离。
  - 2. 适当情况下，两个或者更多进程能够共享内存。这是因为内核可以将不同进程的页表条目指向相同的RAM页，通常有如下场景:
    - 1. 执行同一进程的多个进程，可共享一份(只读的)程序代码副本。当多个程序执行相同的程序文件(动态链接库)时，会**隐式地**实现这一类型的共享。
    - 2. 进程可以使用`shmget()/mmap()`系统调用显式地请求与其他进程共享内存区。
  - 3. 便于实现内存保护机制，可以对页表条目进行标记: 可读，可写，可执行或是这些保护措施的组合。多个进程共享RAM页面时，允许每个进程对内存采取不同的保护措施。
  - 4. 程序员和编译器、链接器之类的工具不用关注程序在RAM中的内存布局。
  - 5. 因为需要驻留在内存中的仅是程序的一部分，所以程序的加载和运行都很快。而且，一个进程所占用的内存能够超出RAM容量。
  - 6. 每个进程占用的RAM减少了，则RAM中同时能够运行的进程数量就增多了，这样可以增加CPU的利用率。

## 5. 栈和栈帧
- 函数的调用和返回使栈的增长和收缩呈线性。栈驻留在内存的高端(高地址)并向下增长(朝堆的方向)，专用寄存器: 栈指针(stack pointer)，用于跟踪当前栈顶。每次函数调用时，会在栈上新分配一帧，每当函数返回时，再从栈上将此帧移去。
- 用户栈和内核栈需要区分开来。内核栈是每个进程保留在内核内存中的内存区域，在执行系统调用的过程中供(内核)内部函数调用使用。
- 用户栈帧包含如下信息:
  - 1. 函数实参和局部变量，这些将在函数被调用时自动创建，也称为自动变量，这个是和全局变量的主要区别。全局变量与函数无关，且长期存在。
  - 2. 函数调用的链接信息: 每个函数都会用到一些CPU寄存器，比如程序计数器，其指向下一条将要执行的机器语言指令。每当调用另一函数时，都会在栈帧中保存这些寄存器的副本，方便在函数返回时能为函数调用者将寄存器恢复原状。
- 函数能够嵌套调用，所以栈中可能有多个栈帧。

## 6. 命令行参数(argc, argv)
- 命令行参数argc表示参数个数，包含程序自身的个数，而argv则是一个字符串数组，每一个都是一个字符串(包含字符串结束符)，数组的最后一个是空指针。
- argv[0]包含了调用程序的名称，可以利用这一特性玩个实用的小技巧:
  - 首先为同一程序创建多个链接(即名称不同)，然后让程序查看argv[0],并根据调用程序的名称来执行不同任务。gzip/gunzip/zcat就是该技术应用的一个例子。
- argc/argv只能在main函数内使用，如果想要在其他地方使用，可以使用一个全局变量指向他们。还有两个方法，但是会影响程序的可移植性:
  - 1. 通过linux专有的`/proc/<pid>/cmdline`文件可以读取任一进程的命令行参数。
  - 2. GNU C语言库提供有两个全局变量，可在程序内任一位置使用以获取调用该程序的程序名称(即命令行的第一个参数)。
    - 1. 第一个全局变量`program_invocation_name`, 提供了用于调用该程序的完整路径名，等价于argv[0]。
    - 2. 第二个全局变量`program_invocation_short_name`, 通过了用于调用该程序的不含目录的程序名称。
    - 3. **使用方法**: 需要引用`<errno.h>`并添加测试宏`_GNU_SOURCE`
- `ARG_MAX`常量的下限，SUSv3规定为`_POSIX_ARG_MAX`(4096), 大多数Unix都远高于此。linux则在x86-32中为32个页面即: 131072个字节，从内核2.6.23版本开始，可以使用资源限制`RLIMIT_STACK`来控制argv和environ参数所使用的空间总量上限。具体限额为`RLIMIT_STACK`的四分之一。

## 7. 环境列表
- 每一个进程都有与其相关的称之为环境列表的字符串数组，或简称环境。其中每个字符串都是以`名称=值(name=value)`形式定义。常将列表中的名称称为**环境变量**
- 新进程创建时，会继承父进程的环境副本。这是一种原始的进程间通信方式: 单向的，一次性的。子进程获取了环境副本后，和父进程的环境无任何关联，也相互不可见。
- 环境变量经常用于shell中，通过在自身环境中放置变量值，shell就可以吧这些值传递给其创建的进程，并以此来执行用户命令。
- 可以通过设置环境变量来改变一些库函数行为: 如getopt函数，通常也可以根据环境变量来进行编程。无需修改程序，传入不同的环境变量就可以控制程序执行不同的操作。
- 大多数shell通过export命令向环境中添加变量值:
  - 例如:
  ```shell
  $ SHELL=/bin/bash
  $ export SHELL
  ```
  - 在bash和ksh中，可以简写为:
  ```shell
  $ export SHELL=/bin/bash
  ```
  - 在csh中，使用的则是命令: setenv
  ```shell
  $ setenv SHELL /bin/bash
  ```
- 上述的命令把一个值永久的添加到了shell环境中了，此后这个shell创建的子进程都将继承环境。在任意时刻，可以通过`unset`命令来撤销一个环境变量(csh是unsetenv命令)。
- sh和bash/ksh可以使用下列语法向执行某应用程序的环境中添加一个变量值，而不影响其父shell
  - 例如:
  ```shell
  $ NAME=value program
  ```
  - 当有多个变量的时候，可以添加多对，每对用空格分隔。
  ```shell
  $ NAME1=value1 NAME2=value2 ... program
  ```
  